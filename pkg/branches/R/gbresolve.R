.fetch_gbhierarchy.above=function(gb, rank="root", within=""){
	
## returns taxonomic information for a 'taxon' up to the 'rank' given
## requires fetch_genbank.pl and potentially nodes.dmp and names.dmp (if /tmp/idx is not available)
	
	if(!all(names(gb)%in%c("nodes","names"))){
			stop("Please rebuild NCBI taxdump with .build.gbtaxdump()")
	}
	Linnaean=c(
		       "root",
			   "superkingdom",
			   "kingdom",
			   "superphylum",
			   "phylum",
			   "subphylum",
			   "superclass",
			   "class",
			   "subclass",
			   "infraclass",
			   "superorder",
			   "order",
			   "suborder",
			   "parvorder",
			   "infraorder",
			   "superfamily",
			   "family",
			   "subfamily",
			   "tribe",
			   "subtribe",
			   "genus",
			   "subgenus",
#			   "species group",
#		       "species subgroup",
			   "species",
			   "subspecies",
			   "varietas",
			   "forma"
	)
	
	nodes=gb$nodes
	names=gb$names
	
	# COMBINE nodes and names
	dat=cbind(names, nodes[match(names$id, nodes$id), c("parent_id", "rank")])
	rownames(dat)=NULL
	
	get_tax=function(name){
		
		# resolve highest rank requested
		if(!is.null(rank)) if(!rank%in%Linnaean) {
			cat(paste("Ensure that supplied 'rank' is in: \n\t", paste(Linnaean, collapse="\n\t"), "\n", sep=""))
			stop("Supplied 'rank' is unrecognized.")
		}
		
		rank=match.arg(rank, Linnaean)
		
		name=gsub("_", " ", name) 
		sci=dat$type=="scientific name"

		fetch_anc=function(id){
			ww=which(dat$id==id & sci==TRUE)
			if(length(ww)!=1) return(NA)
			ww
		}
		

		# resolve 'name' to 'id'
		idx=which(dat$node==name)
		
		## NO MATCH -- use grep
		if(!length(idx)){
			idx=grep(name, dat$node, ignore.case=TRUE)
			if(!length(idx)==1){
				if(length(unique(dat$parent_id))==1){
					idx=min(idx)
				} else {
					if(length(idx)>1) warning(paste("Attempt one of the following:\n\t", paste(dat$node[idx], collapse="\n\t"), sep=""))
					return(NA)
				}
			}
		}
		
		## MORE THAN ONE MATCH -- see if all point to same 'anc'
		if(length(idx)>1){
			if(length(unique(dat$parent_id))==1){
				idx=min(idx)
			} else {
				if(within=="") {
					warning(paste(sQuote(name), "does not appear to be a unique 'name'"))
					return(NA)
				}
			}
		}
		
		alltax=function(idx){
			## COMMON NAME --- resolve to scientific name
			if(!all(dat$type[idx]=="scientific name")){
				idx=sapply(idx, function(x){
					while(1){
						   xx=fetch_anc(dat$id[x])
						   if(dat$type[xx]=="scientific name") break()
					}
					return(xx)
				})
				
				
			}
			
			id=dat$id[idx]
			
			
			## COLLECT TAXONOMY
			pnms=character()
			rnks=character()
			
			cur=id
			rr=""
			while(rr!=rank){
				orig=cur
				idx=fetch_anc(cur)
				pnm=dat$node[idx]
				pid=dat$parent_id[idx]
				pnms=c(pnms, pnm)
				cur=pid
				rr=dat$rank[idx]
				rnks=c(rnks, rr)
				if(rr==rank || orig==pid || pnm=="root") break()
			}
			
			res=pnms
			names(res)=rnks
			res=res[names(res)%in%Linnaean]
			return(res)			
		}
		
		if(length(idx)>1){
			tmp=lapply(idx, alltax)
			ww=sapply(tmp, function(x) tolower(within)%in%tolower(x))
			if(any(ww)){
				if(sum(ww)>1){
					uu=table(names(unlist(tmp[which(ww)])))
					uu=names(uu[uu==sum(ww)])
					x=sapply(tmp[which(ww)], function(y) digest(y[names(y)%in%uu]))
					if(length(unique(x))==1){
						ll=sapply(tmp[which(ww)], length)
						return(tmp[[which(ww)[min(which(ll==max(ll)))]]])
					} else {
						warning(paste("Attempt one of the following:\n\t", paste(sapply(tmp[which(ww)], function(x) x[[1]]), collapse="\n\t"), sep=""))
					}
				} else {
					return(tmp[[which(ww)]])
				}
			} else {
				return(NA)
			}
		} else {
			if(within!=""){
				tmp=alltax(idx)
				if(tolower(within)%in%tolower(tmp)){
					return(tmp)
				} else {
					warning(paste(sQuote(name), "was encountered in NCBI taxonomy but not found within", sQuote(within)))
					return(NA)

				}
			} else {
				tmp=alltax(idx)
				if(!rank%in%names(tmp)){
					warning(paste(sQuote(rank), "appears to be a rank inconsistent with NCBI taxonomy for", sQuote(name)))
				}
				return(tmp)
			}
		}
	}
	
	return(get_tax)
}

.path_to_gb.dmp=function(package="PhyloOrchard"){
	path=paste(system.file(package=package), "data", sep="/")
#	pl=paths[[which(names(paths)=="fetch_genbank")]]
#	base_path=gsub("fetch_genbank.pl", "", pl)
	nd=paste(path, "nodes.dmp", sep="/")
	nm=paste(path, "names.dmp", sep="/")
	return(c(names=nm, nodes=nd, base=path))
}


## EXPORTING GB taxonomy to R tables
# partly from OMeara phyloorchard code ncbiTaxonomy.R::ncbiTaxonomy()
.build.gbtaxdump=function(update=FALSE){
	
	gb_path=.path_to_gb.dmp()
	rda=paste(gb_path[["base"]], "taxdump.rda", sep="/") 

	build=update
	if(!file.exists(rda) | build){
		build=TRUE
	} else {
		build=FALSE
	}

	if(build){
		if(file.exists("taxdump.tar.gz")) unlink("taxdump.tar.gz")
		cat("Please be patient as 'taxdump' is built from NCBI; download may take several minutes...\n")
		if(!system("which wget", ignore.stdout=TRUE)==0) stop("Install 'wget' before proceeding.")
		if(!system("which gunzip", ignore.stdout=TRUE)==0) stop("Install 'gunzip' before proceeding.")
		if(!system("which tar", ignore.stdout=TRUE)==0) stop("Install 'tar' before proceeding.")
		if(!system("which perl", ignore.stdout=TRUE)==0) stop("Install 'perl' before proceeding.")
		
		
		system("wget ftp://ftp.ncbi.nih.gov/pub/taxonomy/taxdump.tar.gz", ignore.stderr=TRUE, wait=TRUE)
		system("gunzip taxdump.tar.gz", ignore.stderr=TRUE, wait=TRUE)
		system("tar -xvf taxdump.tar", ignore.stderr=TRUE, wait=TRUE)
		system("perl -i -p -e's/[^\\w+^\\s+^\\d+^\\|+]//g' names.dmp")
		system("perl -i -p -e's/[^\\w+^\\s+^\\d+^\\|+]//g' nodes.dmp")
		
		mv=TRUE
		rm=TRUE
		
		if(mv){
			system("rm -rf /tmp/idx")
			if(all(sapply(ff<-c("nodes.dmp", "names.dmp"), file.exists))){
				system(paste("mv nodes.dmp", gb_path[["nodes"]], sep=" "))
				system(paste("mv names.dmp", gb_path[["names"]], sep=" "))
				cleanup=c("taxdump.tar", "readme.txt", "gc.prt", "merged.dmp", "division.dmp", "delnodes.dmp", "citations.dmp", "gencode.dmp")
				cleanup=cleanup[cleanup%in%dir()]
				if(rm) system(paste("rm -f", paste(cleanup, collapse=" "), sep=" "))
			} else {
				stop("Error encountered from NCBI: 'nodes.dmp' and (or) 'names.dmp' cannot be located.")
			}
			
			## CALL UP gb data
			names.dmp<-read.table(gb_path[["names"]],header=FALSE, sep="|",strip.white=TRUE,fill=TRUE,stringsAsFactors=FALSE) 
			names.dmp<-names.dmp[,1:4]
			names(names.dmp)<-c("id", "node", "unique", "type")
			nodes.dmp<-read.table(gb_path[["nodes"]],header=FALSE, sep="|",strip.white=TRUE,fill=TRUE,stringsAsFactors=FALSE)
			nodes.dmp<-nodes.dmp[,c(1:5,11:13)]
			names(nodes.dmp)<-c("id","parent_id","rank","embl_code","division_id","GenBank_hidden_flag","hidden_subtree_root_flag","comments")

			gb=list(nodes=nodes.dmp, names=names.dmp)
			class(gb)=c("taxdump", class(gb))
			save(gb, file=rda)
		}
	}
	

	gb=get(load(rda))
		
	return(gb)

}

#require(auteur)
#data(urodela)
#phy=urodela$phy


## Assign internal node labels to phy based on genbank taxonomy
gbresolve.phylo=function(phy, rank="phylum", within="", ...){
	require(auteur)
	tt=unique(tips<-sapply(phy$tip.label, function(x) unlist(strsplit(x, "_"))[1]))
	
	gb=.build.gbtaxdump(...)
	FUN=.fetch_gbhierarchy.above(gb, rank=rank, within=within)
	
	tax=lapply(tt, function(x) try(FUN(x), silent=TRUE))
	dd=sapply(tax, function(x) inherits(x, "try-error") | all(is.na(x)))
	
	if(any(dd)){
		tt=tt[!dd]
		tax=tax[!dd]
	}
	
	names(tax)=tt
	
	if(!length(tt)) return(NA)
	
	tmp=.compile_taxonomy(tax)
	res=tmp[match(tips, rownames(tmp)),]
	rownames(res)=names(tips)
	aa=apply(res, 1, function(x) all(is.na(x)))
	if(any(aa)) res=res[-which(aa),]
	ll=apply(res, 2, function(x) length(unique(x))==1 & !any(x==""))
	if(any(ll)){
		tmp=res[,1:min(which(ll))]
	} else {
		tmp=res
	}
	
	phy=nodelabel.phylo(phy, tmp)
	return(list(phy=phy, tax=res))
	
}

print.taxdump=function(x, ...){
	cat("\nNCBI GenBank taxdump\n")
	xnm=nrow(x$names)
    cat("\nnames:", xnm,"\n")
	print(rbind(x$names[c(1:5),],  matrix(".", nrow=5, ncol=ncol(x$names), dimnames=list(NULL, dimnames(x$names)[[2]])), x$names[c((xnm-4):xnm),]))

	xnd=nrow(x$nodes)
	cat("\nnodes:", xnd, "\n")	
	print(rbind(x$nodes[c(1:5),], matrix(".", nrow=5, ncol=ncol(x$nodes), dimnames=list(NULL, dimnames(x$nodes)[[2]])), x$nodes[c((xnd-4):xnd),]))
}

.compile_taxonomy=function(tax){
	all=c("forma", "superkingdom", "kingdom", 
		  "superphylum", "phylum", "subphylum", "superclass", "class", 
		  "subclass", "infraclass", "superorder", "order", "suborder", 
		  "parvorder", "infraorder", "superfamily", "family", "subfamily", 
		  "tribe", "subtribe", "genus", "subgenus", "species", 
		  "subspecies", "varietas")
	tmp=sapply(tax, names)
	drop=sapply(tmp, function(x) all(is.null(x)))
	dat=tax
	if(any(drop)) {
		dat=dat[-which(drop)]
		tmp=tmp[-which(drop)]
	}
	taxa=tmp
	levels=unique(unlist(taxa))
	mm=match(all, levels)
	hier=rev(all[!is.na(mm)])
	mm=matrix("", nrow=length(dat), ncol=length(hier))
	for(i in 1:length(dat)){
		cur=dat[[i]]
		mm[i,match(names(cur), hier)]=cur
	}
	
	## exclude peculiar assignments (e.g., Proteus [salamander genus] returns prokaryotic labels)
	## FIX ME: more problem anticipation
	primary=table(mm[,ncol(mm)])
	zz=mm[,ncol(mm)]!=names(primary[primary==max(primary)])
	if(any(zz)) {
		mm=mm[-which(zz),]
		dat=dat[-which(zz)]
	}
	mm[is.na(mm)]=""
	rownames(mm)=names(dat)
	colnames(mm)=hier
	mm
}


